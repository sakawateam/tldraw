{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["export interface TLBezierCurveSegment {\n  start: number[]\n  tangentStart: number[]\n  normalStart: number[]\n  pressureStart: number\n  end: number[]\n  tangentEnd: number[]\n  normalEnd: number[]\n  pressureEnd: number\n}\n\n/**\n * Get bezier curve segments that pass through an array of points.\n * @param points\n * @param tension\n */\nexport function getTLBezierCurveSegments(\n  points: number[][],\n  tension = 0.4\n): TLBezierCurveSegment[] {\n  const len = points.length\n  const cpoints: number[][] = [...points]\n\n  if (len < 2) {\n    throw Error('Curve must have at least two points.')\n  }\n\n  for (let i = 1; i < len - 1; i++) {\n    const p0 = points[i - 1]\n    const p1 = points[i]\n    const p2 = points[i + 1]\n\n    const pdx = p2[0] - p0[0]\n    const pdy = p2[1] - p0[1]\n    const pd = Math.hypot(pdx, pdy)\n    const nx = pdx / pd // normalized x\n    const ny = pdy / pd // normalized y\n    const dp = Math.hypot(p1[0] - p0[0], p1[1] - p0[1]) // Distance to previous\n    const dn = Math.hypot(p1[0] - p2[0], p1[1] - p2[1]) // Distance to next\n\n    cpoints[i] = [\n      // tangent start\n      p1[0] - nx * dp * tension,\n      p1[1] - ny * dp * tension,\n      // tangent end\n      p1[0] + nx * dn * tension,\n      p1[1] + ny * dn * tension,\n      // normal\n      nx,\n      ny,\n    ]\n  }\n\n  // TODO: Reflect the nearest control points, not average them\n  const d0 = Math.hypot(points[0][0] + cpoints[1][0])\n  cpoints[0][2] = (points[0][0] + cpoints[1][0]) / 2\n  cpoints[0][3] = (points[0][1] + cpoints[1][1]) / 2\n  cpoints[0][4] = (cpoints[1][0] - points[0][0]) / d0\n  cpoints[0][5] = (cpoints[1][1] - points[0][1]) / d0\n\n  const d1 = Math.hypot(points[len - 1][1] + cpoints[len - 1][1])\n  cpoints[len - 1][0] = (points[len - 1][0] + cpoints[len - 2][2]) / 2\n  cpoints[len - 1][1] = (points[len - 1][1] + cpoints[len - 2][3]) / 2\n  cpoints[len - 1][4] = (cpoints[len - 2][2] - points[len - 1][0]) / -d1\n  cpoints[len - 1][5] = (cpoints[len - 2][3] - points[len - 1][1]) / -d1\n\n  const results: TLBezierCurveSegment[] = []\n\n  for (let i = 1; i < cpoints.length; i++) {\n    results.push({\n      start: points[i - 1].slice(0, 2),\n      tangentStart: cpoints[i - 1].slice(2, 4),\n      normalStart: cpoints[i - 1].slice(4, 6),\n      pressureStart: 2 + ((i - 1) % 2 === 0 ? 1.5 : 0),\n      end: points[i].slice(0, 2),\n      tangentEnd: cpoints[i].slice(0, 2),\n      normalEnd: cpoints[i].slice(4, 6),\n      pressureEnd: 2 + (i % 2 === 0 ? 1.5 : 0),\n    })\n  }\n\n  return results\n}\n\n/**\n * Find a point along a curve segment, via pomax.\n * @param t\n * @param points [cpx1, cpy1, cpx2, cpy2, px, py][]\n */\nexport function computePointOnCurve(t: number, points: number[][]): number[] {\n  // shortcuts\n  if (t === 0) {\n    return points[0]\n  }\n\n  const order = points.length - 1\n\n  if (t === 1) {\n    return points[order]\n  }\n\n  const mt = 1 - t\n  let p = points // constant?\n\n  if (order === 0) {\n    return points[0]\n  } // linear?\n\n  if (order === 1) {\n    return [mt * p[0][0] + t * p[1][0], mt * p[0][1] + t * p[1][1]]\n  } // quadratic/cubic curve?\n\n  // if (order < 4) {\n  const mt2 = mt * mt\n  const t2 = t * t\n\n  let a: number\n  let b: number\n  let c: number\n  let d = 0\n\n  if (order === 2) {\n    p = [p[0], p[1], p[2], [0, 0]]\n    a = mt2\n    b = mt * t * 2\n    c = t2\n    // } else if (order === 3) {\n  } else {\n    a = mt2 * mt\n    b = mt2 * t * 3\n    c = mt * t2 * 3\n    d = t * t2\n  }\n\n  return [\n    a * p[0][0] + b * p[1][0] + c * p[2][0] + d * p[3][0],\n    a * p[0][1] + b * p[1][1] + c * p[2][1] + d * p[3][1],\n  ]\n  // } // higher order curves: use de Casteljau's computation\n}\n\n/**\n * Evaluate a 2d cubic bezier at a point t on the x axis.\n * @param tx\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n */\nexport function cubicBezier(tx: number, x1: number, y1: number, x2: number, y2: number): number {\n  // Inspired by Don Lancaster's two articles\n  // http://www.tinaja.com/glib/cubemath.pdf\n  // http://www.tinaja.com/text/bezmath.html\n\n  // Set start and end point\n  const x0 = 0\n  const y0 = 0\n  const x3 = 1\n  const y3 = 1\n  // Convert the coordinates to equation space\n  const A = x3 - 3 * x2 + 3 * x1 - x0\n  const B = 3 * x2 - 6 * x1 + 3 * x0\n  const C = 3 * x1 - 3 * x0\n  const D = x0\n  const E = y3 - 3 * y2 + 3 * y1 - y0\n  const F = 3 * y2 - 6 * y1 + 3 * y0\n  const G = 3 * y1 - 3 * y0\n  const H = y0\n  // Variables for the loop below\n  const iterations = 5\n\n  let i: number\n  let slope: number\n  let x: number\n  let t = tx\n\n  // Loop through a few times to get a more accurate time value, according to the Newton-Raphson method\n  // http://en.wikipedia.org/wiki/Newton's_method\n  for (i = 0; i < iterations; i++) {\n    // The curve's x equation for the current time value\n    x = A * t * t * t + B * t * t + C * t + D\n\n    // The slope we want is the inverse of the derivate of x\n    slope = 1 / (3 * A * t * t + 2 * B * t + C)\n\n    // Get the next estimated time value, which will be more accurate than the one before\n    t -= (x - tx) * slope\n    t = t > 1 ? 1 : t < 0 ? 0 : t\n  }\n\n  // Find the y value through the curve's y equation, with the now more accurate time value\n  return Math.abs(E * t * t * t + F * t * t + G * t * H)\n}\n\n/**\n * Get a bezier curve data for a spline that fits an array of points.\n * @param points An array of points formatted as [x, y]\n * @param k Tension\n */\nexport function getSpline(\n  pts: number[][],\n  k = 0.5\n): {\n  cp1x: number\n  cp1y: number\n  cp2x: number\n  cp2y: number\n  px: number\n  py: number\n}[] {\n  let p0: number[]\n  let [p1, p2, p3] = pts\n\n  const results: {\n    cp1x: number\n    cp1y: number\n    cp2x: number\n    cp2y: number\n    px: number\n    py: number\n  }[] = []\n\n  for (let i = 1, len = pts.length; i < len; i++) {\n    p0 = p1\n    p1 = p2\n    p2 = p3\n    p3 = pts[i + 2] ? pts[i + 2] : p2\n\n    results.push({\n      cp1x: p1[0] + ((p2[0] - p0[0]) / 6) * k,\n      cp1y: p1[1] + ((p2[1] - p0[1]) / 6) * k,\n      cp2x: p2[0] - ((p3[0] - p1[0]) / 6) * k,\n      cp2y: p2[1] - ((p3[1] - p1[1]) / 6) * k,\n      px: pts[i][0],\n      py: pts[i][1],\n    })\n  }\n\n  return results\n}\n\n/**\n * Get a bezier curve data for a spline that fits an array of points.\n * @param pts\n * @param tension\n * @param isClosed\n * @param numOfSegments\n */\nexport function getCurvePoints(\n  pts: number[][],\n  tension = 0.5,\n  isClosed = false,\n  numOfSegments = 3\n): number[][] {\n  const _pts = [...pts]\n  const len = pts.length\n  const res: number[][] = [] // results\n\n  let t1x: number, // tension Vectors\n    t2x: number,\n    t1y: number,\n    t2y: number,\n    c1: number, // cardinal points\n    c2: number,\n    c3: number,\n    c4: number,\n    st: number,\n    st2: number,\n    st3: number\n\n  // The algorithm require a previous and next point to the actual point array.\n  // Check if we will draw closed or open curve.\n  // If closed, copy end points to beginning and first points to end\n  // If open, duplicate first points to befinning, end points to end\n  if (isClosed) {\n    _pts.unshift(_pts[len - 1])\n    _pts.push(_pts[0])\n  } else {\n    // copy 1. point and insert at beginning\n    _pts.unshift(_pts[0])\n    _pts.push(_pts[len - 1])\n    // _pts.push(_pts[len - 1])\n  }\n\n  // For each point, calculate a segment\n  for (let i = 1; i < _pts.length - 2; i++) {\n    // Calculate points along segment and add to results\n    for (let t = 0; t <= numOfSegments; t++) {\n      // Step\n      st = t / numOfSegments\n      st2 = Math.pow(st, 2)\n      st3 = Math.pow(st, 3)\n\n      // Cardinals\n      c1 = 2 * st3 - 3 * st2 + 1\n      c2 = -(2 * st3) + 3 * st2\n      c3 = st3 - 2 * st2 + st\n      c4 = st3 - st2\n\n      // Tension\n      t1x = (_pts[i + 1][0] - _pts[i - 1][0]) * tension\n      t2x = (_pts[i + 2][0] - _pts[i][0]) * tension\n      t1y = (_pts[i + 1][1] - _pts[i - 1][1]) * tension\n      t2y = (_pts[i + 2][1] - _pts[i][1]) * tension\n\n      // Control points\n      res.push([\n        c1 * _pts[i][0] + c2 * _pts[i + 1][0] + c3 * t1x + c4 * t2x,\n        c1 * _pts[i][1] + c2 * _pts[i + 1][1] + c3 * t1y + c4 * t2y,\n      ])\n    }\n  }\n\n  res.push(pts[pts.length - 1])\n\n  return res\n}\n\n/**\n * Simplify a line (using Ramer-Douglas-Peucker algorithm).\n * @param points An array of points as [x, y, ...][]\n * @param tolerance The minimum line distance (also called epsilon).\n * @returns Simplified array as [x, y, ...][]\n */\n\nexport function simplify(points: number[][], tolerance = 1): number[][] {\n  const len = points.length\n  const a = points[0]\n  const b = points[len - 1]\n  const [x1, y1] = a\n  const [x2, y2] = b\n\n  if (len > 2) {\n    let distance = 0\n    let index = 0\n    const max = Math.hypot(y2 - y1, x2 - x1)\n\n    for (let i = 1; i < len - 1; i++) {\n      const [x0, y0] = points[i]\n      const d = Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / max\n\n      if (distance > d) continue\n\n      distance = d\n      index = i\n    }\n\n    if (distance > tolerance) {\n      const l0 = simplify(points.slice(0, index + 1), tolerance)\n      const l1 = simplify(points.slice(index + 1), tolerance)\n      return l0.concat(l1.slice(1))\n    }\n  }\n\n  return [a, b]\n}\n"],
  "mappings": "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",
  "names": []
}
