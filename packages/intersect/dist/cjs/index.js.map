{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": ["import { Vec } from '@tldraw/vec'\n\nexport type TLIntersection = {\n  didIntersect: boolean\n  message: string\n  points: number[][]\n}\n\nexport interface TLBounds {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  width: number\n  height: number\n  rotation?: number\n}\n\n/**\n * Get an intersection.\n * @param message\n * @param points\n * @internal\n */\nfunction createIntersection(message: string, ...points: number[][]): TLIntersection {\n  const didIntersect = points.length > 0\n  return { didIntersect, message, points }\n}\n\n/**\n *\n * @param point\n * @param size\n * @param rotation\n * @internal\n */\nfunction getRectangleSides(point: number[], size: number[], rotation = 0): [string, number[][]][] {\n  const center = [point[0] + size[0] / 2, point[1] + size[1] / 2]\n  const tl = Vec.rotWith(point, center, rotation)\n  const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation)\n  const br = Vec.rotWith(Vec.add(point, size), center, rotation)\n  const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation)\n\n  return [\n    ['top', [tl, tr]],\n    ['right', [tr, br]],\n    ['bottom', [br, bl]],\n    ['left', [bl, tl]],\n  ]\n}\n\n/**\n * Get whether angle c lies between angles a and b.\n * @param a\n * @param b\n * @param c\n * @internal\n */\nfunction isAngleBetween(a: number, b: number, c: number): boolean {\n  if (c === a || c === b) return true\n  const PI2 = Math.PI * 2\n  const AB = (b - a + PI2) % PI2\n  const AC = (c - a + PI2) % PI2\n  return AB <= Math.PI !== AC > AB\n}\n\n/* -------------------------------------------------- */\n/*                         Ray                        */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersection between a ray and a ray.\n * @param p0 The first ray's point\n * @param n0 The first ray's direction vector.\n * @param p1 The second ray's point.\n * @param n1 The second ray's direction vector.\n */\nexport function intersectRayRay(\n  p0: number[],\n  n0: number[],\n  p1: number[],\n  n1: number[]\n): TLIntersection {\n  const dx = p1[0] - p0[0]\n  const dy = p1[1] - p0[1]\n  const det = n1[0] * n0[1] - n1[1] * n0[0]\n  const u = (dy * n1[0] - dx * n1[1]) / det\n  const v = (dy * n0[0] - dx * n0[1]) / det\n  if (u < 0 || v < 0) return createIntersection('miss')\n\n  const m0 = n0[1] / n0[0]\n  const m1 = n1[1] / n1[0]\n  const b0 = p0[1] - m0 * p0[0]\n  const b1 = p1[1] - m1 * p1[0]\n  const x = (b1 - b0) / (m0 - m1)\n  const y = m0 * x + b0\n\n  return Number.isFinite(x)\n    ? createIntersection('intersection', [x, y])\n    : createIntersection('parallel')\n}\n\n/**\n * Find the intersections between a ray and a line segment.\n * @param origin\n * @param direction\n * @param a1\n * @param a2\n */\nexport function intersectRayLineSegment(\n  origin: number[],\n  direction: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  const [x, y] = origin\n  const [dx, dy] = direction\n  const [x1, y1] = a1\n  const [x2, y2] = a2\n\n  if (dy / dx !== (y2 - y1) / (x2 - x1)) {\n    const d = dx * (y2 - y1) - dy * (x2 - x1)\n    if (d !== 0) {\n      const r = ((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)) / d\n      const s = ((y - y1) * dx - (x - x1) * dy) / d\n      if (r >= 0 && s >= 0 && s <= 1) {\n        return createIntersection('intersection', [x + r * dx, y + r * dy])\n      }\n    }\n  }\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between a ray and a rectangle.\n * @param origin\n * @param direction\n * @param point\n * @param size\n * @param rotation\n */\nexport function intersectRayRectangle(\n  origin: number[],\n  direction: number[],\n  point: number[],\n  size: number[],\n  rotation = 0\n): TLIntersection[] {\n  return intersectRectangleRay(point, size, rotation, origin, direction)\n}\n\n/**\n * Find the intersections between a ray and an ellipse.\n * @param origin\n * @param direction\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectRayEllipse(\n  origin: number[],\n  direction: number[],\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation: number\n): TLIntersection {\n  const a1 = origin\n  const a2 = Vec.mul(direction, 999999999)\n  return intersectLineSegmentEllipse(a1, a2, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between a ray and a bounding box.\n * @param origin\n * @param direction\n * @param bounds\n * @param rotation\n */\nexport function intersectRayBounds(\n  origin: number[],\n  direction: number[],\n  bounds: TLBounds,\n  rotation = 0\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRayRectangle(origin, direction, [minX, minY], [width, height], rotation)\n}\n\n/* -------------------------------------------------- */\n/*                    Line Segment                    */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersection between a line segment and a ray.\n * @param a1\n * @param a2\n * @param origin\n * @param direction\n */\nexport function intersectLineSegmentRay(\n  a1: number[],\n  a2: number[],\n  origin: number[],\n  direction: number[]\n): TLIntersection {\n  return intersectRayLineSegment(origin, direction, a1, a2)\n}\n\n/**\n * Find the intersection between a line segment and a line segment.\n * @param a1\n * @param a2\n * @param b1\n * @param b2\n */\nexport function intersectLineSegmentLineSegment(\n  a1: number[],\n  a2: number[],\n  b1: number[],\n  b2: number[]\n): TLIntersection {\n  const AB = Vec.sub(a1, b1)\n  const BV = Vec.sub(b2, b1)\n  const AV = Vec.sub(a2, a1)\n\n  const ua_t = BV[0] * AB[1] - BV[1] * AB[0]\n  const ub_t = AV[0] * AB[1] - AV[1] * AB[0]\n  const u_b = BV[1] * AV[0] - BV[0] * AV[1]\n\n  if (ua_t === 0 || ub_t === 0) {\n    return createIntersection('coincident')\n  }\n\n  if (u_b === 0) {\n    return createIntersection('parallel')\n  }\n\n  if (u_b !== 0) {\n    const ua = ua_t / u_b\n    const ub = ub_t / u_b\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return createIntersection('intersection', Vec.add(a1, Vec.mul(AV, ua)))\n    }\n  }\n\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between a line segment and a rectangle.\n * @param a1\n * @param a2\n * @param point\n * @param size\n */\nexport function intersectLineSegmentRectangle(\n  a1: number[],\n  a2: number[],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleLineSegment(point, size, a1, a2)\n}\n\n/**\n * Find the intersections between a line segment and an arc.\n * @param a1\n * @param a2\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectLineSegmentArc(\n  a1: number[],\n  a2: number[],\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection {\n  const sa = Vec.angle(center, start)\n  const ea = Vec.angle(center, end)\n  const ellipseTest = intersectEllipseLineSegment(center, radius, radius, 0, a1, a2)\n\n  if (!ellipseTest.didIntersect) return createIntersection('no intersection')\n\n  const points = ellipseTest.points.filter((point) =>\n    isAngleBetween(sa, ea, Vec.angle(center, point))\n  )\n\n  if (points.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n\n/**\n * Find the intersections between a line segment and a circle.\n * @param a1\n * @param a2\n * @param c\n * @param r\n */\nexport function intersectLineSegmentCircle(\n  a1: number[],\n  a2: number[],\n  c: number[],\n  r: number\n): TLIntersection {\n  const a = (a2[0] - a1[0]) * (a2[0] - a1[0]) + (a2[1] - a1[1]) * (a2[1] - a1[1])\n  const b = 2 * ((a2[0] - a1[0]) * (a1[0] - c[0]) + (a2[1] - a1[1]) * (a1[1] - c[1]))\n  const cc =\n    c[0] * c[0] +\n    c[1] * c[1] +\n    a1[0] * a1[0] +\n    a1[1] * a1[1] -\n    2 * (c[0] * a1[0] + c[1] * a1[1]) -\n    r * r\n\n  const deter = b * b - 4 * a * cc\n\n  if (deter < 0) {\n    return createIntersection('outside')\n  }\n\n  if (deter === 0) {\n    return createIntersection('tangent')\n  }\n\n  const e = Math.sqrt(deter)\n  const u1 = (-b + e) / (2 * a)\n  const u2 = (-b - e) / (2 * a)\n  if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {\n    if ((u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1)) {\n      return createIntersection('outside')\n    } else {\n      return createIntersection('inside')\n    }\n  }\n\n  const results: number[][] = []\n  if (0 <= u1 && u1 <= 1) results.push(Vec.lrp(a1, a2, u1))\n  if (0 <= u2 && u2 <= 1) results.push(Vec.lrp(a1, a2, u2))\n\n  return createIntersection('intersection', ...results)\n}\n\n/**\n * Find the intersections between a line segment and an ellipse.\n * @param a1\n * @param a2\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectLineSegmentEllipse(\n  a1: number[],\n  a2: number[],\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection {\n  // If the ellipse or line segment are empty, return no tValues.\n  if (rx === 0 || ry === 0 || Vec.isEqual(a1, a2)) {\n    return createIntersection('no intersection')\n  }\n\n  // Get the semimajor and semiminor axes.\n  rx = rx < 0 ? rx : -rx\n  ry = ry < 0 ? ry : -ry\n\n  // Rotate points and translate so the ellipse is centered at the origin.\n  a1 = Vec.sub(Vec.rotWith(a1, center, -rotation), center)\n  a2 = Vec.sub(Vec.rotWith(a2, center, -rotation), center)\n\n  // Calculate the quadratic parameters.\n  const diff = Vec.sub(a2, a1)\n\n  const A = (diff[0] * diff[0]) / rx / rx + (diff[1] * diff[1]) / ry / ry\n  const B = (2 * a1[0] * diff[0]) / rx / rx + (2 * a1[1] * diff[1]) / ry / ry\n  const C = (a1[0] * a1[0]) / rx / rx + (a1[1] * a1[1]) / ry / ry - 1\n\n  // Make a list of t values (normalized points on the line where intersections occur).\n  const tValues: number[] = []\n\n  // Calculate the discriminant.\n  const discriminant = B * B - 4 * A * C\n\n  if (discriminant === 0) {\n    // One real solution.\n    tValues.push(-B / 2 / A)\n  } else if (discriminant > 0) {\n    const root = Math.sqrt(discriminant)\n    // Two real solutions.\n    tValues.push((-B + root) / 2 / A)\n    tValues.push((-B - root) / 2 / A)\n  }\n\n  // Filter to only points that are on the segment.\n  // Solve for points, then counter-rotate points.\n  const points = tValues\n    .filter((t) => t >= 0 && t <= 1)\n    .map((t) => Vec.add(center, Vec.add(a1, Vec.mul(Vec.sub(a2, a1), t))))\n    .map((p) => Vec.rotWith(p, center, rotation))\n\n  return createIntersection('intersection', ...points)\n}\n\n/**\n * Find the intersections between a line segment and a bounding box.\n * @param a1\n * @param a2\n * @param bounds\n */\nexport function intersectLineSegmentBounds(\n  a1: number[],\n  a2: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  return intersectBoundsLineSegment(bounds, a1, a2)\n}\n\n/**\n * Find the intersections between a line segment and a polyline.\n * @param a1\n * @param a2\n * @param points\n */\nexport function intersectLineSegmentPolyline(\n  a1: number[],\n  a2: number[],\n  points: number[][]\n): TLIntersection {\n  const pts: number[][] = []\n\n  for (let i = 1; i < points.length; i++) {\n    const int = intersectLineSegmentLineSegment(a1, a2, points[i - 1], points[i])\n\n    if (int) {\n      pts.push(...int.points)\n    }\n  }\n\n  if (pts.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n/**\n * Find the intersections between a line segment and a closed polygon.\n * @param a1\n * @param a2\n * @param points\n */\nexport function intersectLineSegmentPolygon(\n  a1: number[],\n  a2: number[],\n  points: number[][]\n): TLIntersection {\n  const pts: number[][] = []\n\n  for (let i = 1; i < points.length + 1; i++) {\n    const int = intersectLineSegmentLineSegment(a1, a2, points[i - 1], points[i % points.length])\n\n    if (int) {\n      pts.push(...int.points)\n    }\n  }\n\n  if (pts.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n\n/* -------------------------------------------------- */\n/*                      Rectangle                     */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a rectangle and a ray.\n * @param point\n * @param size\n * @param rotation\n * @param origin\n * @param direction\n */\nexport function intersectRectangleRay(\n  point: number[],\n  size: number[],\n  rotation: number,\n  origin: number[],\n  direction: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size, rotation).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectRayLineSegment(origin, direction, a1, a2)\n\n      if (intersection) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a line segment.\n * @param point\n * @param size\n * @param a1\n * @param a2\n */\nexport function intersectRectangleLineSegment(\n  point: number[],\n  size: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [b1, b2]]) => {\n      const intersection = intersectLineSegmentLineSegment(a1, a2, b1, b2)\n\n      if (intersection) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a rectangle.\n * @param point1\n * @param size1\n * @param point2\n * @param size2\n */\nexport function intersectRectangleRectangle(\n  point1: number[],\n  size1: number[],\n  point2: number[],\n  size2: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point1, size1).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersections = intersectRectangleLineSegment(point2, size2, a1, a2)\n\n      acc.push(\n        ...intersections.map((int) =>\n          createIntersection(`${message} ${int.message}`, ...int.points)\n        )\n      )\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and an arc.\n * @param point\n * @param size\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectRectangleArc(\n  point: number[],\n  size: number[],\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectArcLineSegment(center, radius, start, end, a1, a2)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a circle.\n * @param point\n * @param size\n * @param c\n * @param r\n */\nexport function intersectRectangleCircle(\n  point: number[],\n  size: number[],\n  c: number[],\n  r: number\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentCircle(a1, a2, c, r)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and an ellipse.\n * @param point\n * @param size\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectRectangleEllipse(\n  point: number[],\n  size: number[],\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentEllipse(a1, a2, c, rx, ry, rotation)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a bounding box.\n * @param point\n * @param size\n * @param bounds\n */\nexport function intersectRectangleBounds(\n  point: number[],\n  size: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRectangleRectangle(point, size, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a rectangle and a polyline.\n * @param point\n * @param size\n * @param points\n */\nexport function intersectRectanglePolyline(\n  point: number[],\n  size: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentPolyline(a1, a2, points)\n\n      if (intersection.didIntersect) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n/**\n * Find the intersections between a rectangle and a polygon.\n * @param point\n * @param size\n * @param points\n */\nexport function intersectRectanglePolygon(\n  point: number[],\n  size: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentPolygon(a1, a2, points)\n\n      if (intersection.didIntersect) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/* -------------------------------------------------- */\n/*                         Arc                        */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a arc and a line segment.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param a1\n * @param a2\n */\nexport function intersectArcLineSegment(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentArc(a1, a2, center, radius, start, end)\n}\n\n/**\n * Find the intersections between a arc and a rectangle.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param point\n * @param size\n */\nexport function intersectArcRectangle(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleArc(point, size, center, radius, start, end)\n}\n\n/**\n * Find the intersections between a arc and a bounding box.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param bounds\n */\nexport function intersectArcBounds(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectArcRectangle(center, radius, start, end, [minX, minY], [width, height])\n}\n\n/* -------------------------------------------------- */\n/*                       Circle                       */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a circle and a line segment.\n * @param c\n * @param r\n * @param a1\n * @param a2\n */\nexport function intersectCircleLineSegment(\n  c: number[],\n  r: number,\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentCircle(a1, a2, c, r)\n}\n\n/**\n * Find the intersections between a circle and a circle.\n * @param c1\n * @param r1\n * @param c2\n * @param r2\n */\nexport function intersectCircleCircle(\n  c1: number[],\n  r1: number,\n  c2: number[],\n  r2: number\n): TLIntersection {\n  let dx = c2[0] - c1[0],\n    dy = c2[1] - c1[1]\n\n  const d = Math.sqrt(dx * dx + dy * dy),\n    x = (d * d - r2 * r2 + r1 * r1) / (2 * d),\n    y = Math.sqrt(r1 * r1 - x * x)\n\n  dx /= d\n  dy /= d\n\n  return createIntersection(\n    'intersection',\n    [c1[0] + dx * x - dy * y, c1[1] + dy * x + dx * y],\n    [c1[0] + dx * x + dy * y, c1[1] + dy * x - dx * y]\n  )\n}\n\n/**\n * Find the intersections between a circle and a rectangle.\n * @param c\n * @param r\n * @param point\n * @param size\n */\nexport function intersectCircleRectangle(\n  c: number[],\n  r: number,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleCircle(point, size, c, r)\n}\n\n/**\n * Find the intersections between a circle and a bounding box.\n * @param c\n * @param r\n * @param bounds\n */\nexport function intersectCircleBounds(c: number[], r: number, bounds: TLBounds): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectCircleRectangle(c, r, [minX, minY], [width, height])\n}\n\n/* -------------------------------------------------- */\n/*                       Ellipse                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between an ellipse and a ray.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param point\n * @param direction\n */\nexport function intersectEllipseRay(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  point: number[],\n  direction: number[]\n): TLIntersection {\n  return intersectRayEllipse(point, direction, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and a line segment.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param a1\n * @param a2\n */\nexport function intersectEllipseLineSegment(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0,\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  if (rx === ry) {\n    return intersectLineSegmentCircle(a1, a2, center, rx)\n  }\n\n  return intersectLineSegmentEllipse(a1, a2, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and a rectangle.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param point\n * @param size\n */\nexport function intersectEllipseRectangle(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  if (rx === ry) {\n    return intersectRectangleCircle(point, size, center, rx)\n  }\n\n  return intersectRectangleEllipse(point, size, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and an ellipse.\n * Adapted from https://gist.github.com/drawable/92792f59b6ff8869d8b1\n * @param _c1\n * @param _rx1\n * @param _ry1\n * @param _r1\n * @param _c2\n * @param _rx2\n * @param _ry2\n * @param _r2\n */\nexport function intersectEllipseEllipse(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _c1: number[],\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _rx1: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _ry1: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _r1: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _c2: number[],\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _rx2: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _ry2: number,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _r2: number\n): TLIntersection {\n  // TODO\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between an ellipse and a circle.\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n * @param c2\n * @param r2\n */\nexport function intersectEllipseCircle(\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  c2: number[],\n  r2: number\n): TLIntersection {\n  return intersectEllipseEllipse(c, rx, ry, rotation, c2, r2, r2, 0)\n}\n\n/**\n * Find the intersections between an ellipse and a bounding box.\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n * @param bounds\n */\nexport function intersectEllipseBounds(\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectEllipseRectangle(c, rx, ry, rotation, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a ray.\n * @param bounds\n * @param origin\n * @param direction\n */\nexport function intersectBoundsRay(\n  bounds: TLBounds,\n  origin: number[],\n  direction: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRayRectangle(origin, direction, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a line segment.\n * @param bounds\n * @param a1\n * @param a2\n */\nexport function intersectBoundsLineSegment(\n  bounds: TLBounds,\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectLineSegmentRectangle(a1, a2, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a rectangle.\n * @param bounds\n * @param point\n * @param size\n */\nexport function intersectBoundsRectangle(\n  bounds: TLBounds,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRectangleRectangle(point, size, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a bounding box.\n * @param bounds1\n * @param bounds2\n */\nexport function intersectBoundsBounds(bounds1: TLBounds, bounds2: TLBounds): TLIntersection[] {\n  return intersectRectangleRectangle(\n    [bounds1.minX, bounds1.minY],\n    [bounds1.width, bounds1.height],\n    [bounds2.minX, bounds2.minY],\n    [bounds2.width, bounds2.height]\n  )\n}\n\n/**\n * Find the intersections between a bounding box and an arc.\n * @param bounds\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectBoundsArc(\n  bounds: TLBounds,\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectArcRectangle(center, radius, start, end, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a circle.\n * @param bounds\n * @param c\n * @param r\n */\nexport function intersectBoundsCircle(bounds: TLBounds, c: number[], r: number): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectCircleRectangle(c, r, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and an ellipse.\n * @param bounds\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectBoundsEllipse(\n  bounds: TLBounds,\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectEllipseRectangle(c, rx, ry, rotation, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a polyline.\n * @param bounds\n * @param points\n */\nexport function intersectBoundsPolyline(bounds: TLBounds, points: number[][]): TLIntersection[] {\n  return intersectPolylineBounds(points, bounds)\n}\n\n/**\n * Find the intersections between a bounding box and a polygon.\n * @param bounds\n * @param points\n */\nexport function intersectBoundsPolygon(bounds: TLBounds, points: number[][]): TLIntersection[] {\n  return intersectPolygonBounds(points, bounds)\n}\n\n/* -------------------------------------------------- */\n/*                      Polyline                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a polyline and a line segment.\n * @param points\n * @param a1\n * @param a2\n */\nexport function intersectPolylineLineSegment(\n  points: number[][],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentPolyline(a1, a2, points)\n}\n\n/**\n * Find the intersections between a polyline and a rectangle.\n * @param points\n * @param point\n * @param size\n */\nexport function intersectPolylineRectangle(\n  points: number[][],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectanglePolyline(point, size, points)\n}\n\n/**\n * Find the intersections between a polyline and a bounding box.\n * @param points\n * @param bounds\n */\nexport function intersectPolylineBounds(points: number[][], bounds: TLBounds): TLIntersection[] {\n  return intersectRectanglePolyline(\n    [bounds.minX, bounds.minY],\n    [bounds.width, bounds.height],\n    points\n  )\n}\n\n/* -------------------------------------------------- */\n/*                       Polygon                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a polygon nd a line segment.\n * @param points\n * @param a1\n * @param a2\n */\nexport function intersectPolygonLineSegment(\n  points: number[][],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentPolyline(a1, a2, points)\n}\n\n/**\n * Find the intersections between a polygon and a rectangle.\n * @param points\n * @param point\n * @param size\n */\nexport function intersectPolygonRectangle(\n  points: number[][],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectanglePolyline(point, size, points)\n}\n\n/**\n * Find the intersections between a polygon and a bounding box.\n * @param points\n * @param bounds\n */\nexport function intersectPolygonBounds(points: number[][], bounds: TLBounds): TLIntersection[] {\n  return intersectRectanglePolygon(\n    [bounds.minX, bounds.minY],\n    [bounds.width, bounds.height],\n    points\n  )\n}\n"],
  "mappings": "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",
  "names": []
}
